{"source_path": "data\\validation\\sources\\search_corpus\\algorithms_python\\quantum\\deutsch_jozsa.py.DISABLED.txt", "category": "search", "text": "# DISABLED!!\n#!/usr/bin/env python3\n\"\"\"\nDeutsch-Jozsa Algorithm is one of the first examples of a quantum\nalgorithm that is exponentially faster than any possible deterministic\nclassical algorithm\n\nPremise:\nWe are given a hidden Boolean function f,\nwhich takes as input a string of bits, and returns either 0 or 1:\n\nf({x0,x1,x2,...}) -> 0 or 1, where xn is 0 or 1\n\nThe property of the given Boolean function is that it is guaranteed to\neither be balanced or constant. A constant function returns all 0's\nor all 1's for any input, while a balanced function returns  0's for\nexactly half of all inputs and 1's for the other half. Our task is to\ndetermine whether the given function is balanced or constant.\n\nReferences:\n- https://en.wikipedia.org/wiki/Deutsch-Jozsa_algorithm\n- https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html\n\"\"\"\n\nimport numpy as np\nimport qiskit\n\n\ndef dj_oracle(case: str, num_qubits: int) -> qiskit.QuantumCircuit:\n    \"\"\"\n    Returns a Quantum Circuit for the Oracle function.\n    The circuit returned can represent balanced or constant function,\n    according to the arguments passed\n    \"\"\"\n    # This circuit has num_qubits+1 qubits: the size of the input,\n    # plus one output qubit\n    oracle_qc = qiskit.QuantumCircuit(num_qubits + 1)\n\n    # First, let's deal with the case in which oracle is balanced\n    if case == \"balanced\":\n        # First generate a random number that tells us which CNOTs to\n        # wrap in X-gates:\n        b = np.random.randint(1, 2**num_qubits)\n        # Next, format 'b' as a binary string of length 'n', padded with zeros:\n        b_str = format(b, f\"0{num_qubits}b\")\n        # Next, we place the first X-gates. Each digit in our binary string\n        # corresponds to a qubit, if the digit is 0, we do nothing, if it's 1\n        # we apply an X-gate to that qubit:\n        for index, bit in enumerate(b_str):\n            if bit == \"1\":\n                oracle_qc.x(index)\n        # Do the controlled-NOT gates for each qubit, using the output qubit\n        # as the target:\n        for index in range(num_qubits):\n            oracle_qc.cx(index, num_qubits)\n        # Next, place the final X-gates\n        for index, bit in enumerate(b_str):\n            if bit == \"1\":\n                oracle_qc.x(index)\n\n    # Case in which oracle is constant\n    if case == \"constant\":\n        # First decide what the fixed output of the oracle will be\n        # (either always 0 or always 1)\n        output = np.random.randint(2)\n        if output == 1:\n            oracle_qc.x(num_qubits)\n\n    oracle_gate = oracle_qc.to_gate()\n    oracle_gate.name = \"Oracle\"  # To show when we display the circuit\n    return oracle_gate\n\n\ndef dj_algorithm(\n    oracle: qiskit.QuantumCircuit, num_qubits: int\n) -> qiskit.QuantumCircuit:\n    \"\"\"\n    Returns the complete Deutsch-Jozsa Quantum Circuit,\n    adding Input & Output registers and Hadamard & Measurement Gates,\n    to the Oracle Circuit passed in arguments\n    \"\"\"\n    dj_circuit = qiskit.QuantumCircuit(num_qubits + 1, num_qubits)\n    # Set up the output qubit:\n    dj_circuit.x(num_qubits)\n    dj_circuit.h(num_qubits)\n    # And set up the input register:\n    for qubit in range(num_qubits):\n        dj_circuit.h(qubit)\n    # Let's append the oracle gate to our circuit:\n    dj_circuit.append(oracle, range(num_qubits + 1))\n    # Finally, perform the H-gates again and measure:\n    for qubit in range(num_qubits):\n        dj_circuit.h(qubit)\n\n    for i in range(num_qubits):\n        dj_circuit.measure(i, i)\n\n    return dj_circuit\n\n\ndef deutsch_jozsa(case: str, num_qubits: int) -> qiskit.result.counts.Counts:\n    \"\"\"\n    Main function that builds the circuit using other helper functions,\n    runs the experiment 1000 times & returns the resultant qubit counts\n    >>> deutsch_jozsa(\"constant\", 3)\n    {'000': 1000}\n    >>> deutsch_jozsa(\"balanced\", 3)\n    {'111': 1000}\n    \"\"\"\n    # Use Aer's simulator\n    simulator = qiskit.Aer.get_backend(\"aer_simulator\")\n\n    oracle_gate = dj_oracle(case, num_qubits)\n    dj_circuit = dj_algorithm(oracle_gate, num_qubits)\n\n    # Execute the circuit on the simulator\n    job = qiskit.execute(dj_circuit, simulator, shots=1000)\n\n    # Return the histogram data of the results of the experiment.\n    return job.result().get_counts(dj_circuit)\n\n\nif __name__ == \"__main__\":\n    print(f\"Deutsch Jozsa - Constant Oracle: {deutsch_jozsa('constant', 3)}\")\n    print(f\"Deutsch Jozsa - Balanced Oracle: {deutsch_jozsa('balanced', 3)}\")\n", "chars": 4470}