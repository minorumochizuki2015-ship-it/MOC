{"source_path": "data\\validation\\sources\\search_corpus\\algorithms_python\\quantum\\bb84.py.DISABLED.txt", "category": "search", "text": "#!/usr/bin/env python3\n\"\"\"\nSimulation of the Quantum Key Distribution (QKD) protocol called BB84,\ncreated by Charles Bennett and Gilles Brassard in 1984.\n\nBB84 is a key-distribution protocol that ensures secure key distribution\nusing qubits instead of classical bits. The generated key is the result\nof simulating a quantum circuit. Our algorithm to construct the circuit\nis as follows:\n\nAlice generates two binary strings. One encodes the basis for each qubit:\n\n - 0 -> {0,1} basis.\n - 1 -> {+,-} basis.\n\nThe other encodes the state:\n\n - 0 -> |0> or |+>.\n - 1 -> |1> or |->.\n\nBob also generates a binary string and uses the same convention to choose\na basis for measurement. Based on the following results, we follow the\nalgorithm below:\n\nX|0> = |1>\n\nH|0> = |+>\n\nHX|0> = |->\n\n1. Whenever Alice wants to encode 1 in a qubit, she applies an\nX (NOT) gate to the qubit. To encode 0, no action is needed.\n\n2. Wherever she wants to encode it in the {+,-} basis, she applies\nan H (Hadamard) gate. No action is necessary to encode a qubit in\nthe {0,1} basis.\n\n3. She then sends the qubits to Bob (symbolically represented in\nthis circuit using wires).\n\n4. Bob measures the qubits according to his binary string for\nmeasurement. To measure a qubit in the {+,-} basis, he applies\nan H gate to the corresponding qubit and then performs a measurement.\n\nReferences:\nhttps://en.wikipedia.org/wiki/BB84\nhttps://qiskit.org/textbook/ch-algorithms/quantum-key-distribution.html\n\"\"\"\nimport numpy as np\nimport qiskit\n\n\ndef bb84(key_len: int = 8, seed: int | None = None) -> str:\n    \"\"\"\n    Performs the BB84 protocol using a key made of `key_len` bits.\n    The two parties in the key distribution are called Alice and Bob.\n    Args:\n        key_len: The length of the generated key in bits. The default is 8.\n\n        seed: Seed for the random number generator.\n        Mostly used for testing. Default is None.\n\n    Returns:\n        key: The key generated using BB84 protocol.\n\n    >>> bb84(16, seed=0)\n    '[phone]'\n\n    >>> bb84(8, seed=0)\n    '[phone]'\n    \"\"\"\n    # Set up the random number generator.\n    rng = np.random.default_rng(seed=seed)\n\n    # Roughly 25% of the qubits will contribute to the key.\n    # So we take more than we need.\n    num_qubits = 6 * key_len\n    # Measurement basis for Alice's qubits.\n    alice_basis = rng.integers(2, size=num_qubits)\n    # The set of states Alice will prepare.\n    alice_state = rng.integers(2, size=num_qubits)\n    # Measurement basis for Bob's qubits.\n    bob_basis = rng.integers(2, size=num_qubits)\n\n    # Quantum Circuit to simulate BB84\n    bb84_circ = qiskit.QuantumCircuit(num_qubits, name=\"BB84\")\n\n    # Alice prepares her qubits according to rules above.\n    for index, _ in enumerate(alice_basis):\n        if alice_state[index] == 1:\n            bb84_circ.x(index)\n        if alice_basis[index] == 1:\n            bb84_circ.h(index)\n    bb84_circ.barrier()\n\n    # Bob measures the received qubits according to rules above.\n    for index, _ in enumerate(bob_basis):\n        if bob_basis[index] == 1:\n            bb84_circ.h(index)\n\n    bb84_circ.barrier()\n    bb84_circ.measure_all()\n\n    # Simulate the quantum circuit.\n    sim = qiskit.Aer.get_backend(\"aer_simulator\")\n    # We only need to run one shot because the key is unique.\n    # Multiple shots will produce the same key.\n    job = qiskit.execute(bb84_circ, sim, shots=1, seed_simulator=seed)\n    # Returns the result of measurement.\n    result = job.result().get_counts(bb84_circ).most_frequent()\n\n    # Extracting the generated key from the simulation results.\n    # Only keep measurement results where Alice and Bob chose the same basis.\n    gen_key = \"\".join(\n        [\n            result_bit\n            for alice_basis_bit, bob_basis_bit, result_bit in zip(\n                alice_basis, bob_basis, result\n            )\n            if alice_basis_bit == bob_basis_bit\n        ]\n    )\n\n    # Get final key. Pad with 0 if too short, otherwise truncate.\n    key = gen_key[:key_len] if len(gen_key) >= key_len else gen_key.ljust(key_len, \"0\")\n    return key\n\n\nif __name__ == \"__main__\":\n    print(f\"The generated key is : {bb84(8, seed=0)}\")\n    from doctest import testmod\n\n    testmod()\n", "chars": 4194}