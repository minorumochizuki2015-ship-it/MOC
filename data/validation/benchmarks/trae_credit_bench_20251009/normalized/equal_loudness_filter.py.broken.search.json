{"source_path": "data\\validation\\sources\\search_corpus\\algorithms_python\\audio_filters\\equal_loudness_filter.py.broken.txt", "category": "search", "text": "from json import loads\nfrom pathlib import Path\n\nimport numpy as np\nfrom yulewalker import yulewalk\n\nfrom audio_filters.butterworth_filter import make_highpass\nfrom audio_filters.iir_filter import IIRFilter\n\ndata = loads((Path(__file__).resolve().parent / \"loudness_curve.json\").read_text())\n\n\nclass EqualLoudnessFilter:\n    r\"\"\"\n    An equal-loudness filter which compensates for the human ear's non-linear response\n     to sound.\n    This filter corrects this by cascading a yulewalk filter and a butterworth filter.\n\n    Designed for use with samplerate of 44.1kHz and above. If you're using a lower\n     samplerate, use with caution.\n\n    Code based on matlab implementation at https://bit.ly/3eqh2HU\n    (url shortened for ruff)\n\n    Target curve: https://i.imgur.com/3g2VfaM.png\n    Yulewalk response: https://i.imgur.com/J9LnJ4C.png\n    Butterworth and overall response: https://i.imgur.com/3g2VfaM.png\n\n    Images and original matlab implementation by David Robinson, 2001\n    \"\"\"\n\n    def __init__(self, samplerate: int = 44100) -> None:\n        self.yulewalk_filter = IIRFilter(10)\n        self.butterworth_filter = make_highpass(150, samplerate)\n\n        # pad the data to nyquist\n        curve_freqs = np.array(data[\"frequencies\"] + [max(20000.0, samplerate / 2)])\n        curve_gains = np.array(data[\"gains\"] + [140])\n\n        # Convert to angular frequency\n        freqs_normalized = curve_freqs / samplerate * 2\n        # Invert the curve and normalize to 0dB\n        gains_normalized = np.power(10, (np.min(curve_gains) - curve_gains) / 20)\n\n        # Scipy's `yulewalk` function is a stub, so we're using the\n        #  `yulewalker` library instead.\n        # This function computes the coefficients using a least-squares\n        #  fit to the specified curve.\n        ya, yb = yulewalk(10, freqs_normalized, gains_normalized)\n        self.yulewalk_filter.set_coefficients(ya, yb)\n\n    def process(self, sample: float) -> float:\n        \"\"\"\n        Process a single sample through both filters\n\n        >>> filt = EqualLoudnessFilter()\n        >>> filt.process(0.0)\n        0.0\n        \"\"\"\n        tmp = self.yulewalk_filter.process(sample)\n        return self.butterworth_filter.process(tmp)\n", "chars": 2210}