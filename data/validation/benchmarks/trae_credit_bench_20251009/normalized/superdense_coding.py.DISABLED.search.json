{"source_path": "data\\validation\\sources\\search_corpus\\algorithms_python\\quantum\\superdense_coding.py.DISABLED.txt", "category": "search", "text": "\"\"\"\nBuild the superdense coding protocol. This quantum\ncircuit can send two classical bits using one quantum\nbit. This circuit is designed using the Qiskit\nframework. This experiment run in IBM Q simulator\nwith 1000 shots.\n.\nReferences:\nhttps://qiskit.org/textbook/ch-algorithms/superdense-coding.html\nhttps://en.wikipedia.org/wiki/Superdense_coding\n\"\"\"\n\nimport math\n\nimport qiskit\nfrom qiskit import Aer, ClassicalRegister, QuantumCircuit, QuantumRegister, execute\n\n\ndef superdense_coding(bit_1: int = 1, bit_2: int = 1) -> qiskit.result.counts.Counts:\n    \"\"\"\n    The input refer to the classical message\n    that you wants to send. {'00','01','10','11'}\n    result for default values: {11: 1000}\n               ┌───┐          ┌───┐\n    qr_0: ─────┤ X ├──────────┤ X ├─────\n          ┌───┐└─┬─┘┌───┐┌───┐└─┬─┘┌───┐\n    qr_1: ┤ H ├──■──┤ X ├┤ Z ├──■──┤ H ├\n          └───┘     └───┘└───┘     └───┘\n    cr: 2/══════════════════════════════\n    Args:\n        bit_1: bit 1 of classical information to send.\n        bit_2: bit 2 of classical information to send.\n    Returns:\n        qiskit.result.counts.Counts: counts of send state.\n    >>> superdense_coding(0,0)\n    {'00': 1000}\n    >>> superdense_coding(0,1)\n    {'01': 1000}\n    >>> superdense_coding(-1,0)\n    Traceback (most recent call last):\n        ...\n    ValueError: inputs must be positive.\n    >>> superdense_coding(1,'j')\n    Traceback (most recent call last):\n        ...\n    TypeError: inputs must be integers.\n    >>> superdense_coding(1,0.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: inputs must be exact integers.\n    >>> superdense_coding(2,1)\n    Traceback (most recent call last):\n        ...\n    ValueError: inputs must be less or equal to 1.\n    \"\"\"\n    if isinstance(bit_1, str) or isinstance(bit_2, str):\n        raise TypeError(\"inputs must be integers.\")\n    if (bit_1 < 0) or (bit_2 < 0):\n        raise ValueError(\"inputs must be positive.\")\n    if (math.floor(bit_1) != bit_1) or (math.floor(bit_2) != bit_2):\n        raise ValueError(\"inputs must be exact integers.\")\n    if (bit_1 > 1) or (bit_2 > 1):\n        raise ValueError(\"inputs must be less or equal to 1.\")\n\n    # build registers\n    qr = QuantumRegister(2, \"qr\")\n    cr = ClassicalRegister(2, \"cr\")\n\n    quantum_circuit = QuantumCircuit(qr, cr)\n\n    # entanglement the qubits\n    quantum_circuit.h(1)\n    quantum_circuit.cx(1, 0)\n\n    # send the information\n    c_information = str(bit_1) + str(bit_2)\n\n    if c_information == \"11\":\n        quantum_circuit.x(1)\n        quantum_circuit.z(1)\n    elif c_information == \"10\":\n        quantum_circuit.z(1)\n    elif c_information == \"01\":\n        quantum_circuit.x(1)\n    else:\n        quantum_circuit.i(1)\n\n    # unentangled the circuit\n    quantum_circuit.cx(1, 0)\n    quantum_circuit.h(1)\n\n    # measure the circuit\n    quantum_circuit.measure(qr, cr)\n\n    backend = Aer.get_backend(\"aer_simulator\")\n    job = execute(quantum_circuit, backend, shots=1000)\n\n    return job.result().get_counts(quantum_circuit)\n\n\nif __name__ == \"__main__\":\n    print(f\"Counts for classical state send: {superdense_coding(1,1)}\")\n", "chars": 3123}