{"source_path": "data\\validation\\sources\\search_corpus\\algorithms_python\\quantum\\half_adder.py.DISABLED.txt", "category": "search", "text": "# DISABLED!!\n#!/usr/bin/env python3\n\"\"\"\nBuild a half-adder quantum circuit that takes two bits as input,\nencodes them into qubits, then runs the half-adder circuit calculating\nthe sum and carry qubits, observed over 1000 runs of the experiment\n.\n\nReferences:\nhttps://en.wikipedia.org/wiki/Adder_(electronics)\nhttps://qiskit.org/textbook/ch-states/atoms-computation.html#4.2-Remembering-how-to-add-\n\"\"\"\n\nimport qiskit\n\n\ndef half_adder(bit0: int, bit1: int) -> qiskit.result.counts.Counts:\n    \"\"\"\n    >>> half_adder(0, 0)\n    {'00': 1000}\n    >>> half_adder(0, 1)\n    {'01': 1000}\n    >>> half_adder(1, 0)\n    {'01': 1000}\n    >>> half_adder(1, 1)\n    {'10': 1000}\n    \"\"\"\n    # Use Aer's simulator\n    simulator = qiskit.Aer.get_backend(\"aer_simulator\")\n\n    qc_ha = qiskit.QuantumCircuit(4, 2)\n    # encode inputs in qubits 0 and 1\n    if bit0 == 1:\n        qc_ha.x(0)\n    if bit1 == 1:\n        qc_ha.x(1)\n    qc_ha.barrier()\n\n    # use cnots to write XOR of the inputs on qubit2\n    qc_ha.cx(0, 2)\n    qc_ha.cx(1, 2)\n\n    # use ccx / toffoli gate to write AND of the inputs on qubit3\n    qc_ha.ccx(0, 1, 3)\n    qc_ha.barrier()\n\n    # extract outputs\n    qc_ha.measure(2, 0)  # extract XOR value\n    qc_ha.measure(3, 1)  # extract AND value\n\n    # Execute the circuit on the qasm simulator\n    job = qiskit.execute(qc_ha, simulator, shots=1000)\n\n    # Return the histogram data of the results of the experiment\n    return job.result().get_counts(qc_ha)\n\n\nif __name__ == \"__main__\":\n    counts = half_adder(1, 1)\n    print(f\"Half Adder Output Qubit Counts: {counts}\")\n", "chars": 1568}