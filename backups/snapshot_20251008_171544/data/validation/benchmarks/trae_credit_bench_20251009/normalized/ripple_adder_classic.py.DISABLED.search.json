{"source_path": "data\\validation\\sources\\search_corpus\\algorithms_python\\quantum\\ripple_adder_classic.py.DISABLED.txt", "category": "search", "text": "# https://github.com/rupansh/QuantumComputing/blob/master/rippleadd.py\n# https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder\n# https://en.wikipedia.org/wiki/Controlled_NOT_gate\n\nimport qiskit\nfrom qiskit.providers import Backend\n\n\ndef store_two_classics(val1: int, val2: int) -> tuple[qiskit.QuantumCircuit, str, str]:\n    \"\"\"\n    Generates a Quantum Circuit which stores two classical integers\n    Returns the circuit and binary representation of the integers\n    \"\"\"\n    x, y = bin(val1)[2:], bin(val2)[2:]  # Remove leading '0b'\n\n    # Ensure that both strings are of the same length\n    if len(x) > len(y):\n        y = y.zfill(len(x))\n    else:\n        x = x.zfill(len(y))\n\n    # We need (3 * number of bits in the larger number)+1 qBits\n    # The second parameter is the number of classical registers, to measure the result\n    circuit = qiskit.QuantumCircuit((len(x) * 3) + 1, len(x) + 1)\n\n    # We are essentially \"not-ing\" the bits that are 1\n    # Reversed because it's easier to perform ops on more significant bits\n    for i in range(len(x)):\n        if x[::-1][i] == \"1\":\n            circuit.x(i)\n    for j in range(len(y)):\n        if y[::-1][j] == \"1\":\n            circuit.x(len(x) + j)\n\n    return circuit, x, y\n\n\ndef full_adder(\n    circuit: qiskit.QuantumCircuit,\n    input1_loc: int,\n    input2_loc: int,\n    carry_in: int,\n    carry_out: int,\n):\n    \"\"\"\n    Quantum Equivalent of a Full Adder Circuit\n    CX/CCX is like 2-way/3-way XOR\n    \"\"\"\n    circuit.ccx(input1_loc, input2_loc, carry_out)\n    circuit.cx(input1_loc, input2_loc)\n    circuit.ccx(input2_loc, carry_in, carry_out)\n    circuit.cx(input2_loc, carry_in)\n    circuit.cx(input1_loc, input2_loc)\n\n\n# The default value for **backend** is the result of a function call which is not\n# normally recommended and causes ruff to raise a B008 error. However, in this case,\n# this is acceptable because `Aer.get_backend()` is called when the function is defined\n# and that same backend is then reused for all function calls.\n\n\ndef ripple_adder(\n    val1: int,\n    val2: int,\n    backend: Backend = qiskit.Aer.get_backend(\"aer_simulator\"),  # noqa: B008\n) -> int:\n    \"\"\"\n    Quantum Equivalent of a Ripple Adder Circuit\n    Uses qasm_simulator backend by default\n\n    Currently only adds 'emulated' Classical Bits\n    but nothing prevents us from doing this with hadamard'd bits :)\n\n    Only supports adding positive integers\n\n    >>> ripple_adder(3, 4)\n    7\n    >>> ripple_adder(10, 4)\n    14\n    >>> ripple_adder(-1, 10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both Integers must be positive!\n    \"\"\"\n\n    if val1 < 0 or val2 < 0:\n        raise ValueError(\"Both Integers must be positive!\")\n\n    # Store the Integers\n    circuit, x, y = store_two_classics(val1, val2)\n\n    \"\"\"\n    We are essentially using each bit of x & y respectively as full_adder's input\n    the carry_input is used from the previous circuit (for circuit num > 1)\n\n    the carry_out is just below carry_input because\n    it will be essentially the carry_input for the next full_adder\n    \"\"\"\n    for i in range(len(x)):\n        full_adder(circuit, i, len(x) + i, len(x) + len(y) + i, len(x) + len(y) + i + 1)\n        circuit.barrier()  # Optional, just for aesthetics\n\n    # Measure the resultant qBits\n    for i in range(len(x) + 1):\n        circuit.measure([(len(x) * 2) + i], [i])\n\n    res = qiskit.execute(circuit, backend, shots=1).result()\n\n    # The result is in binary. Convert it back to int\n    return int(next(iter(res.get_counts())), 2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "chars": 3603}