{"source_path": "data\\validation\\sources\\search_corpus\\algorithms_python\\quantum\\q_full_adder.py.DISABLED.txt", "category": "search", "text": "\"\"\"\nBuild the quantum full adder (QFA) for any sum of\ntwo quantum registers and one carry in. This circuit\nis designed using the Qiskit framework. This\nexperiment run in IBM Q simulator with 1000 shots.\n.\nReferences:\nhttps://www.quantum-inspire.com/kbase/full-adder/\n\"\"\"\n\nimport math\n\nimport qiskit\n\n\ndef quantum_full_adder(\n    input_1: int = 1, input_2: int = 1, carry_in: int = 1\n) -> qiskit.result.counts.Counts:\n    \"\"\"\n    # >>> q_full_adder(inp_1, inp_2, cin)\n    # the inputs can be 0/1 for qubits in define\n    # values, or can be in a superposition of both\n    # states with hadamard gate using the input value 2.\n    # result for default values: {11: 1000}\n    qr_0: ──■────■──────────────■──\n            │  ┌─┴─┐          ┌─┴─┐\n    qr_1: ──■──┤ X ├──■────■──┤ X ├\n            │  └───┘  │  ┌─┴─┐└───┘\n    qr_2: ──┼─────────■──┤ X ├─────\n          ┌─┴─┐     ┌─┴─┐└───┘\n    qr_3: ┤ X ├─────┤ X ├──────────\n          └───┘     └───┘\n    cr: 2/═════════════════════════\n    Args:\n        input_1: input 1 for the circuit.\n        input_2: input 2 for the circuit.\n        carry_in: carry in for the circuit.\n    Returns:\n        qiskit.result.counts.Counts: sum result counts.\n    >>> quantum_full_adder(1, 1, 1)\n    {'11': 1000}\n    >>> quantum_full_adder(0, 0, 1)\n    {'01': 1000}\n    >>> quantum_full_adder(1, 0, 1)\n    {'10': 1000}\n    >>> quantum_full_adder(1, -4, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: inputs must be positive.\n    >>> quantum_full_adder('q', 0, 1)\n    Traceback (most recent call last):\n        ...\n    TypeError: inputs must be integers.\n    >>> quantum_full_adder(0.5, 0, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: inputs must be exact integers.\n    >>> quantum_full_adder(0, 1, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: inputs must be less or equal to 2.\n    \"\"\"\n    if (\n        isinstance(input_1, str)\n        or isinstance(input_2, str)\n        or isinstance(carry_in, str)\n    ):\n        raise TypeError(\"inputs must be integers.\")\n\n    if (input_1 < 0) or (input_2 < 0) or (carry_in < 0):\n        raise ValueError(\"inputs must be positive.\")\n\n    if (\n        (math.floor(input_1) != input_1)\n        or (math.floor(input_2) != input_2)\n        or (math.floor(carry_in) != carry_in)\n    ):\n        raise ValueError(\"inputs must be exact integers.\")\n\n    if (input_1 > 2) or (input_2 > 2) or (carry_in > 2):\n        raise ValueError(\"inputs must be less or equal to 2.\")\n\n    # build registers\n    qr = qiskit.QuantumRegister(4, \"qr\")\n    cr = qiskit.ClassicalRegister(2, \"cr\")\n    # list the entries\n    entry = [input_1, input_2, carry_in]\n\n    quantum_circuit = qiskit.QuantumCircuit(qr, cr)\n\n    for i in range(3):\n        if entry[i] == 2:\n            quantum_circuit.h(i)  # for hadamard entries\n        elif entry[i] == 1:\n            quantum_circuit.x(i)  # for 1 entries\n        elif entry[i] == 0:\n            quantum_circuit.i(i)  # for 0 entries\n\n    # build the circuit\n    quantum_circuit.ccx(0, 1, 3)  # ccx = toffoli gate\n    quantum_circuit.cx(0, 1)\n    quantum_circuit.ccx(1, 2, 3)\n    quantum_circuit.cx(1, 2)\n    quantum_circuit.cx(0, 1)\n\n    quantum_circuit.measure([2, 3], cr)  # measure the last two qbits\n\n    backend = qiskit.Aer.get_backend(\"aer_simulator\")\n    job = qiskit.execute(quantum_circuit, backend, shots=1000)\n\n    return job.result().get_counts(quantum_circuit)\n\n\nif __name__ == \"__main__\":\n    print(f\"Total sum count for state is: {quantum_full_adder(1, 1, 1)}\")\n", "chars": 3528}